@page "/CreateGroup"
@using BAWLib
@using Bike_Around_Worlds.Components.Blazor_Components
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />

<style>
    html,
    body,
    #my-map {
        width: 100%;
        height: 400px; /* Adjusted height for demonstration purposes */
        margin: 0;
    }
</style>
<div class="mainbody">
    <div class="container">
        <div class="row mx-auto mt-lg-5">
            <h3 class="d-flex justify-content-center">Gruppe erstellen</h3>
        </div>
        <div class="row border-bottom border-secondary">
            <div class="col-lg-6 mb-5">
                <EditForm Model="@_group" OnValidSubmit="HandleSubmit" FormName="CreateGroup">
                    <DataAnnotationsValidator />
                    <ValidationSummary />
                    <div class="mb-4 mt-5 pt-4 border-bottom border-secondary">
                        <input type="text" @bind="_group.Name" id="groupname" class="form-control" placeholder="Gruppenname*" />
                    </div>
                    <div class="mb-4 mt-2 pt-4 border-bottom border-secondary">
                        <input type="text" @bind="_group.Description" id="descrip" class="form-control" placeholder="Beschreibung" />
                    </div>
                    <div class="form-check col-6">
                        <input class="form-check-input" type="radio"  @bind="PublicPrivate" name="flexRadioDefault" id="flexRadioDefault1" checked>
                        <label class="form-check-label" for="flexRadioDefault1">
                            Ã–ffentlich
                        </label>
                    </div>
                    <div class="form-check col-6">
                        <input class="form-check-input" type="radio" @bind="PublicPrivate"  name="flexRadioDefault" id="flexRadioDefault2">
                        <label class="form-check-label" for="flexRadioDefault2">
                            Privat
                        </label>
                    </div>
                </EditForm>
            </div>

            <div class="col-lg-6 m-auto">
                <div class="row">
                    <div class="col-lg-4">
                        <label for="pickupDate" class="form-label labels">Start</label>
                        <input type="date" id="pickupDate" class="form-control" @bind="PickupDate" />
                    </div>

                    <div class="col-lg-4">
                        <label for="pickupTime" class="form-label labels">Start Uhrzeit</label>
                        <input type="time" id="pickupTime" class="form-control" @bind="PickupTime" />
                    </div>

                    <div class="col-lg-4">
                        <label for="dropoffDate" class="form-label labels">Ende</label>
                        <input type="date" id="dropoffDate" class="form-control" @bind="DropoffDate" />
                    </div>
                    
                </div>
            </div>
        </div>

        <div class="row mt-3 mb-3">
            <div class="col-lg-6">
                    <h1>Dynamic Route Planner with Geoapify</h1>

                    <label for="start">Start Location:</label>
                    <input type="text" id="start" placeholder="Enter start location (e.g., London)"/>

                    <label for="end">End Location:</label>
                    <input type="text" id="end" placeholder="Enter end location (e.g., Manchester)"/>

                    <button id="planRouteBtn">Plan Route</button>

                    <div id="my-map" style="width: 100%; height: 500px;"></div>
            </div>            
            </div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
    let map = L.map('my-map').setView([48.40921, 15.61415], 10); // Initial map view

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19,
    }).addTo(map);

    const myAPIKey = "65f0613505ff4799a40b3b62ead71e53"; // Geoapify API Key
    let routePolyline; // Variable to hold the route polyline for updating/removal

    // Event Listener for the Route Planning Button
    document.getElementById("planRouteBtn").addEventListener("click", () => {
        const startLocation = document.getElementById("start").value.trim();
        const endLocation = document.getElementById("end").value.trim();

        if (!startLocation || !endLocation) {
            alert("Please enter both start and end locations.");
            return;
        }

        Promise.all([geocodeLocation(startLocation), geocodeLocation(endLocation)])
            .then(([startCoords, endCoords]) => {
                if (startCoords && endCoords) {
                    // Update map view for new route
                    map.setView([startCoords.lat, startCoords.lon], 10);

                    // Routing API URL for Geoapify
                    const routingUrl = `https://api.geoapify.com/v1/routing?waypoints=${startCoords.lon},${startCoords.lat}|${endCoords.lon},${endCoords.lat}&mode=drive&apiKey=${myAPIKey}`;
                    console.log("Routing URL:", routingUrl);

                    // Fetch the route data
                    fetch(routingUrl)
                        .then(response => response.json())
                        .then(routeData => {
                            console.log("Routing API Response:", routeData);

                            // Check if the route features are present
                            if (routeData.features && routeData.features.length > 0) {
                                const route = routeData.features[0];

                                // Debugging - Log the coordinates of the route
                                console.log("Route Coordinates:", route.geometry.coordinates);

                                // Ensure that coordinates are valid
                                if (route.geometry.coordinates && route.geometry.coordinates.length > 0) {
                                    const routeCoordinates = route.geometry.coordinates.map(coord => {
                                        if (Array.isArray(coord) && coord.length === 2) {
                                            return [coord[1], coord[0]]; // Correct order for Leaflet: [lat, lon]
                                        }
                                    }).filter(Boolean); // Remove any undefined values

                                    if (routeCoordinates.length > 0) {
                                        // Clear previous route if it exists
                                        if (routePolyline) {
                                            map.removeLayer(routePolyline); // Remove the previous polyline
                                        }

                                        // Create new polyline for the new route
                                        routePolyline = L.polyline(routeCoordinates, { color: 'red', weight: 5 }).addTo(map);
                                        map.fitBounds(routePolyline.getBounds()); // Adjust map bounds to the route
                                    } else {
                                        alert("No valid coordinates found for the route.");
                                    }
                                } else {
                                    alert("Route contains invalid coordinates.");
                                }
                            } else {
                                alert("No route found between the locations.");
                            }
                        })
                        .catch(err => {
                            console.error("Routing API Error:", err);
                            alert("There was an error fetching the route.");
                        });
                } else {
                    alert("Failed to geocode one or both locations.");
                }
            })
            .catch(err => {
                console.error("Geocoding Error:", err);
                alert("There was an error with geocoding.");
            });
    });

    // Function to geocode location using Geoapify API
    function geocodeLocation(query) {
        const geocodeUrl = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(query)}&apiKey=${myAPIKey}`;

        fetch(`https://maps.geoapify.com/v1/staticmap?apiKey=${myAPIKey}`, requestOptions)
            .then((response) => response.blob()) // Convert the response to a Blob object
            .then((blob) => {
                const reader = new FileReader();
                reader.onload = function() {
                    // Set the image source of the route preview element to the base64 data URL
                    const mapPreview = document.getElementById("route-preview");
                    mapPreview.src = this.result;
                };
                reader.readAsDataURL(blob); // Convert the Blob to a data URL
            })
            .catch((error) => console.error(error)); // Log errors to the console

    }
</script>





@code {
    Groups _group = new Groups();
    public TimeOnly PickupTime { get; set; } = new TimeOnly(10, 0);
    public TimeOnly DropoffTime { get; set; } = new TimeOnly(10, 0);
    public DateOnly PickupDate { get; set; } = DateOnly.FromDateTime(DateTime.Today);
    public DateOnly DropoffDate { get; set; } = DateOnly.FromDateTime(DateTime.Today);
    private string PublicPrivate { get; set; }
    private void HandleSubmit()
    {
    }
}
